// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: transaction.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO transaction (
  occurred_at, description, type
) VALUES (
  $1, $2, $3
)
RETURNING id, occurred_at, description, type
`

type CreateTransactionParams struct {
	OccurredAt  pgtype.Timestamp
	Description pgtype.Text
	Type        TransactionType
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, createTransaction, arg.OccurredAt, arg.Description, arg.Type)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.OccurredAt,
		&i.Description,
		&i.Type,
	)
	return i, err
}

const getTransaction = `-- name: GetTransaction :many
SELECT id, occurred_at, description, type FROM transaction
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetTransaction(ctx context.Context, id int32) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, getTransaction, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.OccurredAt,
			&i.Description,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactions = `-- name: ListTransactions :many
SELECT id, occurred_at, description, type FROM transaction
ORDER BY id
`

func (q *Queries) ListTransactions(ctx context.Context) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, listTransactions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.OccurredAt,
			&i.Description,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactionsWide = `-- name: ListTransactionsWide :many
SELECT transaction_id, account_id, direction, amount_microcredits, account.id, customer_id, type, account_type.id, name, normal
FROM
  entry
  LEFT JOIN account ON entry.account_id = account.id
  LEFT JOIN account_type ON account.type = account_type.id
`

type ListTransactionsWideRow struct {
	TransactionID      int32
	AccountID          int32
	Direction          pgtype.Int4
	AmountMicrocredits pgtype.Int8
	ID                 pgtype.Int4
	CustomerID         pgtype.Int8
	Type               pgtype.Int4
	ID_2               pgtype.Int4
	Name               pgtype.Text
	Normal             pgtype.Int4
}

func (q *Queries) ListTransactionsWide(ctx context.Context) ([]ListTransactionsWideRow, error) {
	rows, err := q.db.Query(ctx, listTransactionsWide)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTransactionsWideRow
	for rows.Next() {
		var i ListTransactionsWideRow
		if err := rows.Scan(
			&i.TransactionID,
			&i.AccountID,
			&i.Direction,
			&i.AmountMicrocredits,
			&i.ID,
			&i.CustomerID,
			&i.Type,
			&i.ID_2,
			&i.Name,
			&i.Normal,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
